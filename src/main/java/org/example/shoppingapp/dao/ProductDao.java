package org.example.shoppingapp.dao;

import org.example.shoppingapp.domain.Order;
import org.example.shoppingapp.domain.OrderItem;
import org.example.shoppingapp.domain.Product;
import org.example.shoppingapp.domain.User;
import org.example.shoppingapp.dto.product.ProductRequest;
import org.hibernate.Session;
import org.springframework.stereotype.Repository;

import javax.persistence.TypedQuery;
import javax.persistence.criteria.*;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Repository
public class ProductDao extends AbstractHibernateDao<Product>{
    public ProductDao() {
        this.setClassType(Product.class);
    }

    public List<Product> getAllProducts() {
        return this.getAll();
    }

    public Product getProductById(Long id) {
        return this.findById(id);
    }

    public void addProduct(Product product) {
        this.add(product);
    }

    public void updateProductById(ProductRequest productInfo, Long productId){
        Session currentSession = this.getCurrentSession();
        Product product = this.getProductById(productId);
        if(productInfo.getDescription() != null && !productInfo.getDescription().isEmpty()){
            product.setDescription(productInfo.getDescription());
        }
        if(productInfo.getName() != null && !productInfo.getName().isEmpty()){
            product.setName(productInfo.getName());
        }
        if(productInfo.getRetailPrice() != null){
            product.setRetailPrice(productInfo.getRetailPrice());
        }
        if(productInfo.getWholesalePrice() != null){
            product.setWholesalePrice(productInfo.getWholesalePrice());
        }
        if(productInfo.getQuantity() != null){
            product.setQuantity(productInfo.getQuantity());
        }

        currentSession.update(product);
    }

    public void updateProductQuantityById(Long productId, int change){
        Session currentSession = this.getCurrentSession();
        Product product = this.getProductById(productId);
        product.setQuantity(product.getQuantity() + change);
        currentSession.update(product);
    }


    public List<Product> getTopKFrequentProductByUserId(Long userId, int k){
        Session currentSession = getCurrentSession();
        CriteriaBuilder criteriaBuilder = currentSession.getCriteriaBuilder();
        CriteriaQuery<Product> criteriaQuery = criteriaBuilder.createQuery(Product.class);
        Root<OrderItem> root = criteriaQuery.from(OrderItem.class);
        Join<OrderItem, Product> productJoin = root.join("product", JoinType.INNER);
        Join<OrderItem, Order> orderJoin = root.join("order", JoinType.INNER);

        Predicate userPredicate = criteriaBuilder.and();
        if(userId != null){
            userPredicate = orderJoin.get("user").get("id").in(userId);
        }
        Predicate orderPredicate = orderJoin.get("orderStatus").in(
                Arrays.asList("Processing", "Completed"));
        criteriaQuery.select(productJoin)
                .groupBy(productJoin)
                .orderBy(criteriaBuilder.desc(criteriaBuilder.count(root)))
                .where(criteriaBuilder.and(userPredicate, orderPredicate));
        return currentSession.createQuery(criteriaQuery)
                .setMaxResults(k)
                .getResultList();
    }

    public List<Product> getTopKRecentProductByUserId(Long userId, int k){
        Session currentSession = getCurrentSession();
        CriteriaBuilder criteriaBuilder = currentSession.getCriteriaBuilder();
        // FROM BELOW, GENERATED BY CHATGPT, I DO NOT UNDERSTAND A BIT OF THESE CODES.
        CriteriaQuery<Object[]> criteriaQuery = criteriaBuilder.createQuery(Object[].class);

        Root<Order> orderRoot = criteriaQuery.from(Order.class);
        Join<Order, OrderItem> orderItemJoin = orderRoot.join("orderItemSet");
        Join<OrderItem, Product> productJoin = orderItemJoin.join("product");
        Predicate userPredicate = orderRoot.get("user").get("id").in(userId);
        Predicate orderPredicate = orderRoot.get("orderStatus").in(
                Arrays.asList("Processing", "Completed"));
        criteriaQuery.multiselect(productJoin, criteriaBuilder.max(orderRoot.get("datePlaced")))
                .groupBy(productJoin)
                .orderBy(criteriaBuilder.desc(criteriaBuilder.max(orderRoot.get("datePlaced"))))
                .where(criteriaBuilder.and(userPredicate, orderPredicate));

        TypedQuery<Object[]> query = currentSession.createQuery(criteriaQuery)
                .setMaxResults(k);

        return query.getResultList().stream()
                .map(r -> (Product)r[0])
                .collect(Collectors.toList());
    }

    public List<Product> getTopKProfitableProducts(int topK){
        Session currentSession = this.getCurrentSession();
        String queryString = "select  p " +
                "from OrderItem oi join oi.product p " +
                "join oi.order o " +
                "where o.orderStatus = 'Completed' " +
                "group by p " +
                "order by sum(oi.purchasedPrice - oi.wholesalePrice) desc ";
        List<Product> result = currentSession.createQuery(queryString, Product.class)
                .setMaxResults(topK)
                .getResultList();
        return result;
    }

    public List<Object[]> getTotalProductSold(){
        //TODO: Change to a product + sold number class to response.
        Session currentSession = this.getCurrentSession();
        String queryString = "select p, sum(oi.quantity) " +
                "from OrderItem oi join oi.product p " +
                "join oi.order o " +
                "where o.orderStatus = 'Completed' " +
                "group by p ";
        List<Object[]> result = currentSession.createQuery(queryString, Object[].class)
                .getResultList();
        return result;
    }
}
